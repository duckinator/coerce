%{
// Based on the grammar file for decadence (https://github.com/nddrylliog/decadence/raw/master/step7/decadence.leg)
// @author Amos Wenger
// @author Nick Markwell

#include <stdio.h>
#include <stdbool.h>

// Store the state of the parser
struct _ParserState {
    /* A pointer to the instance of our Parser */
    void *this;
    /* The path of the file we're currently parsing */
    char *path;
    /* The current line number */
    int yylineno;
    /* The file */
    FILE *file;
};

// Read from a file
#define YY_INPUT(buf, result, max_size)                 \
  {                                                     \
    int yyc = fgetc(core->file);                        \
    result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1);        \
  }

typedef struct _ParserState ParserState;

#define YY_XTYPE ParserState *
#define YY_XVAR core

// That's the type of '$$'
#define YYSTYPE void *

///////////////////// HOOKS ///////////////////////

// Now gotNumber returns a Number object
void *gotNumber(void *this, char *number);

// And so does gotBinaryOp
void *gotBinaryOp(void *this, char *type, void *left, void *right);

void *gotAssignment(void *this, char *left, void *right);

void *gotVariableAccess(void *this, char *name);

void onNode(void *this, void *node);

void gotExpr(void *this, void *node);

void *gotList(void *this, char *string);

void gotListStart(void *this);
void *gotListEnd(void *this);

void *gotStringLiteral(void *this, char *string);
void *gotCharLiteral(void *this, char *chr);
void *gotBoolLiteral(void *this, char *chr);

// stringClone is used because the 'yytext' buffer is overwitten with
// new data often, so we clone what we want to keep
char *stringClone(char *str);

%}

STRING_LIT   = ["] < (!["] ("\\\"" | '\\\\' | '\\a' | '\\b' | '\\t' | '\\n' | '\\v' | '\\f' | '\\r' | '\\0' | EOL | .))* > ["]  -  { $$=gotStringLiteral(core->this, yytext); }
CHAR_LIT     = ['] < (!['] ("\\\'" | '\\\\' | '\\a' | '\\b' | '\\t' | '\\n' | '\\v' | '\\f' | '\\r' | '\\0' | .)) > [']         -  { $$=gotCharLiteral(core->this, yytext); }
BOOL_LIT     = (TRUE_KW &[^A-Za-z_] { $$=(void*) true; } | FALSE_KW &[^A-Za-z_] { $$=(void*) false; }) -

# As you notice, we can name rules, ie. here the Expr is captured as 'e'
# And then we can use it in the actino code.
Program = ([ \t\n])* e:Expr { gotExpr(core->this, e) }

# Try to parse a BinaryOp first, if it fails, parse a Number.
Expr = (Assignment | List) -

# Numbers stay the same, except that we store them in '$$' now.
Number = < '-'? [0-9]+ > - { $$=gotNumber(core->this, yytext) }

# Variable accesses o/ New =)
VariableAccess = n:Name - { $$=gotVariableAccess(core->this, n) }

Value = (Number | STRING_LIT | CHAR_LIT | BOOL_LIT | VariableAccess)

Assignment = l:Name - ':' - r:Expr { $$=gotAssignment(core->this, l, r) }

Name = < [a-zA-Z_] [a-zA-Z0-9_]* > - { $$=stringClone(yytext) }

# A BinaryOp = a Number, and then 0 or more times an operator and another BinaryOp
# BinaryOp = l:Value
#          (- o:Operator - r:Value { $$=l=gotBinaryOp(core->this, o, l, r) })*

List        = '(' WS { gotListStart(core->this); } (
                            v:Value
               ((WS | EOL) v:Value)*
               )? WS CLOSE_PAREN ~{ printf("Malformed list! (%i)\n", G->pos + G->offset); }
                              { $$=gotListEnd(core->this); }

# Operator = < ("+" | "*" | "/" | "-") > { $$=stringClone(yytext) }

# ( and ) group rules
# |  is still or
# < and > still delimit the boundaries of the yytext capture

Comment         = (CommentLine | CommentWithDocs)
CommentLine     = ';' !';' (!EOL .)* EOL
CommentWithDocs = ';;' (!EOL .)* EOL

# Whitespace
-          = [ \t]*
EOL        = ('\n' | '\r\n' | '\r')  { core->yylineno++; }
Terminator = (EOL | Comment)
WS         = ([ \t] | EOL)*


OPEN_PAREN    = '('
CLOSE_PAREN   = ')'
OPEN_BRACKET  = '['
LAMBDA_SEP    = '->'
CLOSE_BRACKET = ']'


%%

// We get the parser object as an argument, and the file we need to parse
int coerceParse(void *this, char *path) {

    GREG *G = YY_ALLOC(sizeof(GREG), 0);
    G->buflen = 0;

    struct _ParserState state = {
        .this = this,
        .path = path,
        .file = fopen(path, "r")
    };
    G->data = &state;

    while (yyparse(G)) {}

    fclose(state.file);
    YY_FREE(G);

    return 0;

}
